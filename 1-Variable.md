# 변수(Variable)

> `변수(Variable)` 는 하나의 값을 저장하기 위해 확보한 `메모리 공간 자체` or 그 메모리 공간을 `식별하기 위해 붙인 이름` (= 값의 위치를 가리키는 상징적인 이름)

```jsx
// 예제 : 10 + 20 은 30을 result 라는 변수에 대입한 것
var result = 10 + 20;
```

- 여기서 `result` 는 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름 = `변수이름`
- 변수에 저장된 값(위 예제에서 30) = `변수값`
- 변수에 값을 저장하는 행위 = `할당(Assignment, 대입, 저장)`
- 변수에 저장된 값을 읽어 들이는 것 = `참조(Reference)`

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbb5job%2FbtrlyrbOF7F%2FPSQkjJo4Ckwy19cbEcqjdK%2Fimg.png" width="500" height="400">

```
[ 💡 Note ]
사람이 이해할 수 있는 언어로 명명한 변수 이름을 통해 변수에 저장된 값의 의미를 명확히 할 수 있다.
즉, "변수에 저장된 값의 의미를 파악할 수 있는 변수 이름은 가독성을 높이는 부수적인 효과도 있다."
코드는 컴퓨터에게 내리는 명령이지만 개발자를 위한 문서이기도 하다.
의도가 명확한 네이밍은 코드를 이해하기 쉽게 만들며, 이는 협업과 품질 향상에 도움을 준다.
```

<br>
<br>

# 식별자(Identifier)

> `식별자(Identifier)` 는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

![식별자](https://miro.medium.com/max/700/0*ilACYeYskIXzCETd.jpeg)

- `myNumber` 라는 식별자는 값 23을 식별할 수 있어야 한다.
- 이를 위해 myNumber 는 값 23이 저장되어 있는 `메모리 주소(0012CCGWH80)` 을 기억한다.
- 즉, 식별자는 `값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 매핑 정보도 메모리에 저장되어야 한다.`

```
이와 같이 식별자는 값이 아니라 "메모리 주소를 기억하고 있다."

식별자로 값을 구별해서 식별한다는 것 = 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의미
즉, 식별자는 "메모리 주소에 붙인 이름"
```

- 변수, 함수, 클래스 등의 이름은 모두 식별자다.
  - 변수이름 → 메모리 상에 존재하는 변수 값을 식별
  - 함수이름 → 메모리 상에 존재하는 함수(자바스크립트에서 함수도 값이다 !)를 식별
- 즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 한다.

<br>
<br>

# 변수 선언(Variable Declaration)

> `변수 선언(Variable Declaration)` 은 값을 저장하기 위한 `메모리 공간을 확보`하고 `변수 이름과 확보된 메모리 공간의 주소를 연결`해서 값을 저장할 수 있게 `준비하는 과정`

- 변수를 사용하려면 반드시 선언이 필요
- 변수 선언시에는 `var`, `let`, `const` 키워드를 사용
- ES6 이전(즉, ES5까지)에는 `var 키워드` 만 사용해서 변수를 선언했다.

```
[ 🍧 맛보기 - var 키워드 단점 ]

블록 레벨 스코프(Block-Level Scope)를 지원하지 않고, 함수 레벨 스코프(Functional-Level Scope)를 지원했다.
이로 인해 의도치 않게 "전역 변수가 선언"되어 심각한 부작용이 발생할 수 있다.

이런 var 키워드의 단점을 보완하기위해 등장한 것들이 ES6에 도입된 let과 const 다.
이 둘은 블록 레벨 스코프를 지원한다.
```

```jsx
var person; // 변수 선언(= "변수 선언문")
```

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4e9yE%2FbtrlyqjGZ2K%2FWQLO9hN5nwtYJxxAKzkH50%2Fimg.png" width="500" height="400">

- 변수 선언문은 `변수 이름을 등록`하고 `값을 저장할 메모리 공간을 확보`한다.
  - 변수 선언한 이후, 변수에 값은 아직 할당하지 않았다.
  - 따라서, 확보된 메모리 공간은 비어있을 것으로 생각할 수 있으나 확보된 메모리 공간에는 자바스크립트 엔진에 의해 `undefined` 값이 `암묵적으로 할당`되어 초기화된다.

```
[ 🍧 맛보기 - undefined ]

undefined 는 자바스크립트에서 제공하는 "원시타입 값(Primitive value)" 이다.
```

<br>

> 자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행한다.

1️⃣ `선언 단계` : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.

2️⃣ `초기화 단계` : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined 를 할당해 초기화한다.

- `var` `let` `const` 키워드를 사용한 변수 선언은 `선언단계와 초기화 단계가 동시에 진행` 된다.
- 예로 들어 `var person;` 에 대해
  - 선언 단계를 통해 변수 이름은 `person 으로 등록`하고
  - 초기화 단계를 통해 person 변수에 `암묵적으로 undefined를 할당` 해 초기화한다.
- 따라서, `var` 키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 기본적으로 `undefined` 라는 값을 갖는다.

```
[ 💡 NOTE - Garbage value ]

초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다.
이러한 값을 "쓰레기 값(Garbage value)" 라고 한다.
자바스크립트에서 var 키워드는 암묵적으로 undefined 값으로 초기화를 수행하기 때문에 이러한 위험으로부터 안전하다.
```

```
[ 🍧 맛보기 - 실행 컨텍스트(Excute Context) ]

변수 이름을 비롯한 모든 식별자는 "실행 컨텍스트에 등록된다."
실행 컨텍스트는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
자바스크립트 엔진은 실행 컨텐스트를 통해 식별자와 스코프를 관리
```

> 변수뿐만 아니라 모든 식별자(함수, 클래스 등)를 사용하려면 반드시 `선언이 필요`하다.

![자바스크립트 ReferenceError](https://www.tutorialexample.com/wp-content/uploads/2020/05/fix-javascript-require-is-not-defined-error.png)

- 선언하지 않은 식별자에 접근하면 `ReferenceError(참조 에러)` 가 발생
- 이는, 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러
